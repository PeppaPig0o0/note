# 数据库



# 基础篇

## 1.数据库发展过程

- 文件操作

  ```python
  """
  小飞----123----18
  
  中飞-456-19
  
  大飞｜789｜20
  """
  ```

- 软件开发目录规范

  ```python
  """
  流星蝴蝶剑
  
  - conf
  - core
  - lib
  - log
  - bin
  - db
  readme.md
  
  """
  ```

- 数据库程序

  关系型数据库：

  MySQL.Oracle.SQL server.DB2.Access

  - 数据之间有关系或者约束

  - 数据通常以表格的形式存储

    | name(str) | pwd  | age(int) |
    | --------- | ---- | -------- |
    | xiaofei   | 123  | 18       |
    | zhongfei  | 456  | 19       |
    | dafei     | 789  | 20       |

  非关系型数据库：

  MongoDB.Redis.Memcache

  - 存储数据通常都是key，value的形式



## 2.SQL语句引入

> mysql就是一款基于网络通信的应用程序，底层一定是用的socket

mysql服务端支持mysql自己的客户端操作数据， 也支持其它编程语言来作为客户端操作数据，**怎么解决语言不通的问题呢？**

- 让服务端精通所有编程语言
- **统一语言（sql语句）**



## 3.MySQL安装

参考mysql安装文档：https://active.clewm.net/FrcyFA



## 4.SQL语句初体验

```sql
-- 每一条sql语句都是以分号结尾的

-- 库 --> 文件夹
-- 表 --> 文件
-- 记录 --> 文件里面的一行行数据

/*
注释
*/

show databases;  -- 查看所有的数据库
\s  -- 查看数据库字符编码以及其它信息的
\c  -- 结束当前语句
exit; -- 退出连接
quit; -- 退出连接

help 命令 -- 查看命令的帮助信息
```

- 操作库

  ```sql
  -- 增
  create database db1;
  create database db1 charset=utf8;  -- 推荐
  create database if not exists db1 charset=utf8;
  -- 删
  drop database if exists db2;
  -- 改
  alter database db2 charset=utf8;
  -- 查
  show databases; -- 查所有数据库
  show create database db1; -- 查一个，查看创建这个数据库的sql语句
  ```

  

- 操作表

  ```sql
  select database(); -- 查看当前所在数据库
  use db1; -- 切换数据库
  
  -- 增
  create table movies(id int, name char); -- 创建表（默认的字符编码，就是库的字符编码）
  create table movies(id int, name char)charset=utf8;  -- 创建表
  -- 删
  drop table movies; -- 删除movies这张表
  -- 改
  alter table movies modify name char(4); -- 修改字段类型
  alter table movies change name Name char(5); -- 修改字段名字和类型
  -- 查
  show tables; -- 查看当前库下所有的表
  show create table movies; -- 查看创建表的sql语句
  describe movies; -- 查看一张表的结构， 简写：desc movies;
  
  
  -- 所有对表的操作，都可以使用绝对路径的方式，这样即便不切换数据库，也可以操作数据库对应的表
  create table db2.movies(id int, name char);
  ```

  

- 操作记录

  ```sql
  -- 增
  insert into movies values(1, '流浪地球'); -- 插入一条记录
  insert into movies values(1, '流浪地球'), (2, '三体'); -- 插入多条记录
  -- 删
  delete from movies where name='三体';
  -- 改
  update movies set name='满江红' where id=1;
  -- 查
  select * from movies; -- 查movies这个表的所有数据
  select name from movies;  -- 查询这张表所有数据的name字段
  select id, name from movies; -- 查询这张表所有数据的id和name字段
  select user, host from mysql.user; -- 查询user表里面所有用户的user字段和host字段
  ```

  

## 5.SQL语句分类

| 类型 | 描述                                           | 关键字                          |
| ---- | ---------------------------------------------- | ------------------------------- |
| DDL  | 数据库定义语言，用来定义和管理数据库或者数据表 | create, alter, drop             |
| DML  | 数据库操纵语言，用来操作数据                   | insert, update, delete          |
| DQL  | 数据库查询语言，用来查询数据                   | select                          |
| DCL  | 数据库控制语言，权限控制                       | grant, revoke, commit, rollback |



## 6.库操作

> 参考前面笔记

语法：

```sql
-- 增
create database [if not exists] <库名> [charset=utf8];
create database [if not exists] <库名> [default charset utf8];
create database [if not exists] <库名> [default character set utf8mb4] [default collate 排序规则];
-- 删
drop database [if exists] <库名>;
-- 改
alter database <库名> charset=utf8;
-- 查
show databases; -- 查所有数据库
show create database <库名>; -- 查一个，查看创建这个数据库的sql语句
```



## 7.表操作

### 7.1 存储引擎

> 表的类型，就是存储引擎

```sql
show engines; -- 查看所有的存储引擎

create table t1(id int, name char)engine=innodb;
create table t2(id int, name char)engine=myisam;
create table t3(id int, name char)engine=memory;
create table t4(id int, name char)engine=blackhole;

insert into t1 values(1, 'a');
insert into t2 values(1, 'a');
insert into t3 values(1, 'a');
insert into t4 values(1, 'a');
```



### 7.2 创建表的语法

```sql
create table <表名>(
    <字段名1> <字段类型>[(宽度)] [约束条件],
    <字段名2> <字段类型>[(宽度)] [约束条件],
    <字段名3> <字段类型>[(宽度)] [约束条件],
    <字段名4> <字段类型>[(宽度)] [约束条件1 约束条件2]
);
-- 宽度指的是字符个数，或者说字符串长度

-- 约束条件，注意顺序
[unsigned] [zerofill] [not null]
-- unsigned：无符号
-- zerofill：0填充
-- not null：非空
```



### 7.3 修改表的语法

```sql

-- 修改存储引擎
alter table <表名> engine=<存储引擎名字>;

-- 修改表名
alter table <表名> rename <新表名>;

-- 增加字段
alter table <表名> add <字段名> <字段类型>[(宽度)] [约束条件] [first|after <字段名>],;

-- 删除字段
alter table <表名> drop <字段名>;

-- 修改字段
alter table <表名> modify <字段名> <新字段类型>[(宽度)] [约束条件];
alter table <表名> change <旧字段名> <新字段名> <新字段类型>[(宽度)] [约束条件];

```



### 7.4 删除和复制表语法

```sql
-- 删除表
drop table <表名>;

-- 复制表
create table <新表名> select * from <旧表名> [条件];

-- 复制表结构
create table <新表名> like <旧表名>;
```



## 8.数据类型

- 数值

  - int

    | 类型      | 大小    | 范围（有符号）                              | 范围（无符号）            | 描述       |
    | --------- | ------- | ------------------------------------------- | ------------------------- | :--------- |
    | tinyint   | 1 Bytes | (-128，127)                                 | (0，255)                  | 很小的整数 |
    | smallint  | 2 Bytes | (-32768，32767)                             | (0，65535)                | 较小的整数 |
    | mediumint | 3 Bytes | (-8388608，8388607)                         | (0，16777215)             | 一般的整数 |
    | **int**   | 4 Bytes | (-2147483648，2147483647)                   | (0，4294967295)           | 标准的整数 |
    | bigint    | 8 Bytes | (-9223372036854775808，9223372036854775807) | (0，18446744073709551615) | 极大的整数 |

    

  - float

    ==乘二取整==

    3.625

    3 -> 11

    0.625 -> 0.625x2 = ==1==.25  0.25x2 = ==0==.5  0.5x2 = ==1==   -> 0.101

    3.625 -> 11.101

    > 浮点数的表现形式：==符号.尾数==.基数.==指数==
    >
    > ±m*2^e^ 
    >
    > 单精度浮点数（32位）：符号（1位）+指数（8位）+尾数（23位）
    >
    > 双精度浮点数（64位）：符号（1位）+指数（11位）+尾数（52位）

    符号：1 -> 负，0 -> 正或0

    指数：

    ​		10000001 -> 129 -> 2

    ​		10000000 -> 128 -> 1

    ​		01111111 -> 127-> 0

    ​		01111110 -> 126 -> -1

    ​		01111101 -> 125 -> -2

    尾数：把小数点前的二进制数，固定为1的规则

    ​		3.625 x 2^-1^ -> 3.625 x 0.5 = 1.8125

    ​		11.101 -> 1.11010000000000000000000		尾数：==11010000000000000000000==

    ​		1.8125 x 2^1^ = 3.625		指数：==^1^== -> 127+1=128 -> ==10000000==

    3.625 -> 11.101的存储方式：0 10000000 11010000000000000000000

    1.1101 -> 1 * 2^0^ + 1 * 2^-1^ + 1 * 2^-2^ + 0 * 2^-3^ + 1 * 2^-4^ = 1 + 0.5 + 0.25 + 0 + 0.0625 = 1.8125 * 2^1^ = 3.625

    3.1

    3 -> 11

    0.1 -> 0.1x2 = 0.2 0.2x2 = 0.4 0.4x2 = 0.8 0.8x2 = 1.6 0.6x2 = 1.2

    3.1 -> 11.0 0011 0011 0011 0011.......

    精度问题：如果小数最后一位不是5的话，不精确，延长循环让精度更高

    无法保存极小的小数：最小非零值

    

    | 类型    | 大小                                   | 范围（有符号）                                               | 范围（无符号）                                               | 描述            |
    | :------ | :------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
    | float   | 4 Bytes float(m, d) m最多255，d最多30  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
    | double  | 8 Bytes double(m, d) m最多255，d最多30 | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
    | decimal | decimal(m,d) m最大65，d最大30          | 依赖于m和d的值                                               | 依赖于m和d的值                                               | 小数值          |

    

- 字符

  - char（定长字符串）

    > char(10) 最多能存10个字符，如果超过10个字符，会直接报错，如果不足10个字符，空格补齐
    >
    > 缺点：浪费空间
    >
    > 优点：存去速度快
    >
    > 范围：0-255字符

  - varchar（变长字符串）

    > varchar(10) 最多能存10个字符，如果超过10个字符，会直接报错，如果不足10个字符，直接存
    >
    > 优点：节省空间
    >
    > 缺点：存取速度慢    头hello头fei头heiheihei
    >
    > 范围：0-65535字节，一行的最大字节数
    >
    > 最大字符数 = （65535-行其它字段总字节数-null标志字节数-长度标志字节数）/ 字符集单字符最大字节数
    
    

- 时间日期

  - year

  - date

  - time

  - datetime

    > 8字节，1000～9999

  - timestamp

    > 4字节，1970～2038

  ```sql
  use db3;
  create table user(
  	id int,
      name varchar(16),
      born year,
      birth date,
      active time,
      reg_time datetime
  );
  insert into user values(1, 'fei', now(), now(), now(), now());
  insert into user values(2, 'jack', '2025', '2025-10-10', '12:00:00', '2025-10-10 12:00:00');
  ```

  

- 枚举

  > enum：单选

  ```sql
  create table t10(
  	id int,
      name varchar(16),
      gender enum('male', 'female', 'other')
  );
  insert into t10 values(1, 'fei', 'male');
  ```

  

- 集合

  > set：多选

  ```sql
  create table t11(
  	id int,
      name varchar(16),
      hobby set('tea', 'cola', 'beer')
  );
  insert into t11 values(1, 'fei', 'tea');
  ```

  

## 9.约束条件

> 注意顺序unsigned zerofill需要放前面

- unsigned：无符号
- zerofill：0填充
- not null：非空
- default <value>：默认值
- unique：唯一

```sql
create table user(id int, name varchar(16) unique);

insert into user values(1, 'fei');

-- 单列唯一
create table user(
    id int unique,
    name varchar(16) unique
);

create table user(
    id int,
    name varchar(16),
    unique(id),
    unique(name)
);

-- 联合唯一
create table app(
	id int,
    host varchar(15),
    port int,
    unique(host, port),
    unique(id)
);

insert into app values
(1, '192.168.3.1', 3306),
(2, '192.168.3.1', 9000),
(3, '192.168.3.2', 3306);

insert into app values
(4, '192.168.3.2', 3306);
```

- primary key：主键（约束特性：不为空，且唯一）

```sql
-- 单列主键
create table t10(
	id int primary key,
    name varchar(16)
);

create table t11(
	name varchar(16),
    age int unique not null
);

-- 复合主键
create table app1(
	id int,
    host varchar(15),
    port int,
    primary key(host, port),
    unique(id)
);

insert into app1 values
(1, '192.168.3.1', 3306),
(2, '192.168.3.1', 9000),
(3, '192.168.3.2', 3306);
```

- auto_increment：自动递增

```sql
create database db4;
use db4;
create table t1(
	id int primary key auto_increment,
    name varchar(16)
);
insert into t1(name) values
('fei'),
('jack'),
('rose');

-- 清空表
delete from t1; -- 只清空数据，不清空自增值
truncate t1; -- 同时清空数据和自增值
```

- foreign key：外键约束

```sql
drop table dep;

create table dep(
	id int primary key,
    name varchar(16),
    `desc` varchar(64)
);

create table emp(
	id int primary key,
    name varchar(16),
    gender enum('male', 'female'),
    mobile varchar(11),
    dep_id int,
    foreign key(dep_id) references dep(id) 
    on delete cascade 
    on update cascade
);

insert into dep values
(1, '研发部', '造火箭的'),
(2, '销售部', '卖火箭的'),
(3, '人事部', '裁员的');
insert into emp values
(1, 'fei', 'male', '131', 1);
insert into emp values
(2, '大仙', 'female', '150', 2),
(3, 'tom', 'female', '139', 2),
(4, 'jack', 'male', '135', 3),
(5, 'rose', 'male', '137', 3);

delete from emp where dep_id=1;
delete from dep where id=1;

update dep set name='市场部' where id=2;
update dep set id=999 where id=2;
```



## 10.关系

- 多对一

```sql
create table dep(
	id int primary key,
    name varchar(16),
    `desc` varchar(64)
);

create table emp(
	id int primary key,
    name varchar(16),
    gender enum('male', 'female'),
    mobile varchar(11),
    dep_id int,
    foreign key(dep_id) references dep(id) 
    on delete cascade 
    on update cascade
);
```



- 多对多

```sql
create table song(
	id int primary key auto_increment,
    name varchar(16) not null
);
create table singer(
	id int primary key auto_increment,
    name varchar(16) not null
);
create table song2singer(
	id int primary key auto_increment,
    singer_id int not null,
    song_id int not null,
    foreign key(singer_id) references singer(id) on delete cascade on update cascade,
    foreign key(song_id) references song(id) on delete cascade on update cascade
);


insert into song(name) values
('以父之名'),
('夜的第七章'),
('止战之殇'),
('夜曲'),
('北京欢迎你');
insert into singer(name) values
('周杰伦'),
('刘欢'),
('韩红'),
('成龙');
insert into song2singer(singer_id, song_id) values
(1,1),
(1,2),
(1,3),
(1,4),
(2,5),
(3,5),
(4,5);
```

- 一对一

```sql
create table customer(
	id int primary key,
    name varchar(16),
    gender enum('male', 'female'),
    mobile varchar(11),
);

create table owner(
	id int primary key,
    room_number varchar(16),
    area int,
    is_loan enum(true,false),
    customer_id int unique,
    foreign key(customer_id) references customer(id) on delete cascade on update cascade
);


insert into customer values
(1, 'fei', 'male', '131'),
(2, '大仙', 'female', '150'),
(3, 'tom', 'female', '139'),
(4, 'jack', 'male', '135'),
(5, 'rose', 'male', '137');

insert into owner values
(1, '688', 300, false, 2),
(1, '233', 180, true, 4);
```



## 11.记录的查询语法

```sql
select distinct <字段.....> from <库名>.<表名> 
	where <过滤条件> 
	group by <分组条件>
	having <过滤条件>
	order by <排序字段> {ASC | DESC} -- 默认升序ASC
	limit n;
```

例子

```sql
create database db5;
use db5;
create table emp(
    id int primary key auto_increment,
    name varchar(16) not null,
    gender enum('male', 'female') not null,
    age int not null,
    salary float(10, 2),
    dep varchar(32),
    notes varchar(64)
);

insert into emp(name, gender, age, salary, dep) values
('关羽', 'male', 20, 8000, '技术部'),
('张飞', 'male', 25, 12000, '技术部'),
('赵云', 'male', 19, 6800, '技术部'),
('马超', 'male', 26, 11000, '技术部'),
('黄忠', 'female', 48, 15000, '技术部'),
('夏侯惇', 'male', 36, 34000, '技术部'),
('典韦', 'male', 19, 6500, '技术部'),
('吕布', 'female', 20, 9000, '技术部'),
('周瑜', 'female',32, 36000, '技术部'),
('文丑', 'male', 27, 24000, '技术部'),

('刘备', 'male', 32, 4000, '市场部'),
('诸葛亮', 'male', 27, 2700, '市场部'),
('庞统', 'male', 37, 4200, '市场部'),
('徐庶', 'male', 36, 4000, '市场部'),
('荀彧', 'male', 25, 2400, '市场部'),
('荀攸', 'male', 25, 2400, '市场部'),
('鲁肃', 'male', 43, 4300, '市场部'),
('司马懿', 'female', 44, 5000, '市场部'),
('杨修', 'male', 19, 800, '市场部'),
('丁仪', 'male', 49, 3500, '市场部'),

('宋江', 'male', 30, 4000, '人事部'),
('吴用', 'male', 38, 3000, '人事部'),
('扈三娘', 'female', 42, 2500, '人事部'),
('顾大嫂', 'female', 38, 3300, '人事部'),
('孙二娘', 'female', 32, 2400, '人事部'),
('丁得孙', 'male', 32, 2800, '人事部'),


('柴进', 'male', 30, 4200, '财务部'),
('卢俊义', 'male', 44, 4000, '财务部');

-- 四则运算
select name,salary*12 from emp;
select name,salary*12 as yearly_salary from emp;
select name,salary*12 yearly_salary from emp;

-- 设置显示格式
-- 姓名：关羽  年龄：20 薪资：8000
-- 姓名：张飞  年龄：25 薪资：12000
-- concat()
select concat('姓名：', name, '    年龄：', age) as '姓名 年龄', concat('薪资：', salary) as '薪资' from emp;
select concat(name, '-', age, '-', salary) as '姓名-年龄-薪资' from emp;
select concat_ws('-', name, age, salary) as '姓名-年龄-薪资' from emp;
```

- where

```sql
-- 年龄大于35的
select name, age from emp where age > 35;

-- 技术部年龄大于35的
select name, dep, age from emp where dep='技术部' and age > 35;

-- 年龄大于等于30，小于等于40
select name, age from emp where age >= 30 and age <= 40;
select name, age from emp where age between 30 and 40; -- 闭区间，包含30和40

-- 年龄小于30，或者年龄大于40
select name, age from emp where age < 30 or age > 40;
select name, age from emp where not age between 30 and 40;

-- 工资3000，4000，5000的员工
select name,salary from emp where salary=3000 or salary=4000 or salary=5000;
select name,salary from emp where salary in (3000, 4000, 5000);

-- is null
select * from emp where notes=''; -- 空字符串不是null
select * from emp where notes is null;
select * from emp where notes is not null;

-- like(模糊匹配)
-- _ 正则里面的.
-- % 正则里面的.*
select * from emp where name like '荀_';
select * from emp where name like '丁%';

-- 正则表达式
select * from emp where name regexp '^丁.*';
-- 查询丁或者荀开头的名字
select * from emp where name regexp '^(丁|荀).*';
```

- group by

```sql
select dep from emp group by dep;

-- 聚合函数
count
max
min
sum
avg

-- 统计"每"个部门的员工数量
select dep,count(id) as emp_count from emp group by dep;

select dep,max(age) from emp group by dep;
select dep,min(salary) from emp group by dep;
select dep,sum(salary) from emp group by dep;
select dep,avg(salary) from emp group by dep;

-- 统计所有员工的平均工资
select avg(salary) from emp;

-- 查询每个部门所有员工名字
select dep, group_concat(name) from emp group by dep;

-- 统计每个部门年龄大于45的员工数量
select dep, count(id) from emp where age>45 group by dep;

-- 统计男员工和女员工的数量
select gender, count(id) from emp group by gender;
select gender as g, count(id) as emp_count from emp group by g having emp_count>10;
```

- having

```sql
-- 查询所有部门内，员工数量小于5的部门名，以及该部门内的员工名和员工数量
select dep, group_concat(name), count(id) from emp group by dep having count(id)<5;

-- 查询各部门年龄大于35的员工超过3个人的部门名，以及大于35的人数
select dep, count(id) from emp where age>35 group by dep having count(id)>3;
```

- order by

```sql
-- 对所有员工，按照工资进行升序
select * from emp order by salary;
select * from emp order by salary desc;  -- 降序
select * from emp order by salary desc, id desc; 
```

- limit

```sql
-- 找出公司里面，工资最高的5个人
select * from emp order by salary desc limit 5;

-- 分页
select * from emp limit 0,10;
select * from emp limit 10,10;
select * from emp limit 20,10;
```



## 12.函数

- 字符串处理函数

```sql
select concat('a', 'b', 'c'); 		-- 字符串拼接
select lower('HELLO'); 				-- 转小写
select upper('hello');				-- 转大写
select lpad('hello', 10, '-');		-- 左填充，用字符串"-"在"hello"的左边填充至10个字符，原字符串长度超过10，则会截取至10个字符
select rpad('hello', 10, '-');		-- 右填充，用字符串"-"在"hello"的右边填充至10个字符，原字符串长度超过10，则会截取至10个字符
select trim('   hello  ');			-- 去掉字符串两端的空格
select substring('hello',2,3); 		-- 字符串切片，从第2个字符开始，切3个字符
```

- 数值处理函数

```sql
select ceil(1.3);			-- 向上取整
select floor(1.6);			-- 向下取整
select mod(10,3);			-- 获取10/2的模
select rand();				-- 获取0～1的随机小数
select round(3.1415926,4);	-- 对3.1415926四舍五入，保留4位小数
```

- 日期处理函数

```sql
select '当前日期', curdate();					    -- 获取当前日期
select '当前时间', curtime();						-- 获取当前时间
select '当前日期时间', now();						-- 获取当前日期和时间
select '年', year('2023-10-08 18:36:59');		-- 获取date_time的年份
select '月', month('2023-10-08 18:36:59');		-- 获取date_time的月份
select '日', day('2023-10-08 18:36:59');			-- 获取date_time的日期
select '时', hour('2023-10-08 18:36:59');		-- 获取date_time的小时
select '分', minute('2023-10-08 18:36:59');		-- 获取date_time的分钟
select '秒', second('2023-10-08 18:36:59');		-- 获取date_time的秒

-- 时间差计算，interval单位:year,month,day,hour,minute,second, microsecond
select date_add(now(), interval 1 year); 						-- 获取从now()开始,1天后的时间
select date_add('2023-10-08 18:36:59', interval 1 month); 		-- 获取指定时间1月后的时间
select datediff('2025-10-08 18:36:59', now()); 					-- 获取两个时间之间的天数，第一个值减去第二个值
select timediff('2023-10-08 18:36:59', '2023-10-08 12:00:00');  -- 获取两个时间之间的时间差值
```

- 流程控制函数

```sql
-- 单分支
select name, if(gender='male', '小哥哥', '小姐姐')as '性别' from emp; 	-- 如果性别等于male返回小哥哥，否则返回小姐姐
select ifnull(gender, '未知') from emp;				 -- 如果第一个值不为空，则返回第一个值，否则返回第二个值
select ifnull(notes, '没有任何内容哦') from emp;

-- 多分支
-- 工资大于10000：核心员工
-- 工资5000-10000：普通员工
-- 工资5000以下：新员工
select
	name,
	case when salary>10000 then '核心员工' when salary>5000 then '普通员工' else '新员工' end as '员工级别'
from emp;

-- 技术部：高级技术顾问
-- 人事部：HR
-- 其它：销售经理
select
	name,
    case dep when '技术部' then '高级技术顾问' when '人事部' then 'HR' else '销售经理' end as '职位'
from emp;
```



## 13.多表查询

```sql
create database db6;
use db6;
create table dep(
	id int primary key auto_increment,
    name varchar(16),
    notes varchar(64)
);
insert into dep(name) values
('总经办'),('技术部'),('市场部'),('人事部'),('财务部'),('后勤部');

create table emp(
    id int primary key auto_increment,
    name varchar(16) not null,
    gender enum('male', 'female') not null,
    age int not null,
    salary float(10, 2),
    post varchar(16),
    join_date date,
    leader_id int,
    dep_id int
);

insert into emp values
(1, '刘备', 'male', 32, 4000, '总经理', '2035-06-01', null, 1),

(2, '关羽', 'male', 20, 8000, '技术总监', '2035-06-05', 1, 2),
(3, '张飞', 'male', 25, 12000, '项目经理', '2035-06-10', 2, 2),
(4, '赵云', 'male', 19, 6800, '产品经理', '2035-06-10', 2, 2),
(5, '马超', 'male', 26, 11000, '后端开发', '2035-07-11', 2, 2),
(6, '黄忠', 'female', 48, 15000, '后端开发', '2035-07-22', 2, 2),
(7, '夏侯惇', 'male', 36, 34000, '后端开发', '2035-07-29', 2, 2),
(8, '典韦', 'male', 19, 6800, '后端开发', '2035-08-02', 2, 2),
(9, '吕布', 'female', 20, 9000, '前端开发', '2035-08-03', 2, 2),
(10, '周瑜', 'female',32, 36000, '前端开发', '2035-08-08', 2,  2),
(11, '文丑', 'male', 27, 24000, '测试', '2035-08-12', 2, 2),

(12, '诸葛亮', 'male', 27, 8000, '市场总监', '2035-06-05', 1, 3),
(13, '庞统', 'male', 37, 4200, '销售', '2035-06-06', 12, 3),
(14, '徐庶', 'male', 36, 4000, '销售', '2035-06-12', 12, 3),
(15, '荀彧', 'male', 25, 2400, '销售', '2035-06-10', 12, 3),
(16, '荀攸', 'male', 25, 2400, '销售', '2035-06-12', 12, 3),
(17, '鲁肃', 'male', 43, 4300, '销售', '2035-06-18', 12, 3),
(18, '司马懿', 'female', 44, 5000, '销售', '2035-06-20', 12, 3),
(19, '杨修', 'male', 19, 800, '销售', '2035-07-10', 12,  3),
(20, '丁仪', 'male', 49, 3500, '销售', '2035-07-11', 12, 3),

(21, '宋江', 'male', 30, 8000, '人事总监', '2035-06-05', 1, 4),
(22, '吴用', 'male', 38, 3000, '人事主管', '2035-06-06', 21, 4),
(23, '扈三娘', 'female', 42, 2500, '招聘专员', '2035-06-11', 21, 4),
(24, '顾大嫂', 'female', 38, 3300, '招聘专员', '2035-06-25', 21, 4),
(25, '孙二娘', 'female', 32, 2400, '绩效专员', '2035-07-22', 21, 4),
(26, '丁得孙', 'male', 32, 2800, '培训专员', '2035-08-10', 21, 4),


(27, '柴进', 'male', 30, 8000, '财务总监', '2035-06-05', 1, 5),
(28, '卢俊义', 'male', 44, 4000, '会计', '2035-08-19', 27, 5),
(29, '晁盖', 'male', 44, 3500, '出纳', '2035-08-20', 27, 5),

(30, '貂蝉', 'female', 36, 800, null, '2035-09-01', null, null);

```

笛卡尔积

> a b c
>
> 1 2 3
>
> a1 a2 a3 b1 b2 b3 c1 c2 c3

- 连接查询

  - 内连接

    > 查询两张表的交集部分

    - 隐式内连接

      > select <字段> from <表a>,  <表b> where <条件>;

      ```sql
      select * from emp, dep where emp.dep_id=dep.id;
      ```

    - 显式内连接

      > select <字段> from <表a> [inner] join  <表b> on <条件>;

      ```sql
      select * from emp join dep on emp.dep_id=dep.id;
      ```

      

  - 外连接

    - 左外连接

      > 查询左表所有数据，包括交集部分
      >
      > select <字段> from <表a> left [outer] join <表b> on <条件>;

      ```sql
      -- 查询所有员工数据和部门信息
      select e.name, d.name from emp e left join dep d on e.dep_id = d.id;
      ```

      

    - 右外连接

      > 查询右表所有数据，包括交集部分
      >
      > select <字段> from <表a> right [outer] join <表b> on <条件>;

      ```sql
      -- 查询所有部门数据，以及对应的员工数据
      select e.name, d.name from emp e right join dep d on e.dep_id=d.id;
      select e.name, d.name from dep d left join emp e on e.dep_id = d.id;
      ```

      

  - 自连接

    > select <字段> from <表a> <a> join <表a> <b> on <条件>;
    >
    > 可以用内连接.外连接

    ```sql
    -- 查询有部门的员工及其领导信息
    select a.name '员工', b.name '领导' from emp a join emp b on a.leader_id=b.id;
    -- 查询所有员工及其领导信息，包括没有领导的
    select a.name '员工', a.post '职位', b.name '领导' from emp a left join emp b on a.leader_id=b.id;
    ```

  - 联合查询

    > 把多次查询的结果合并在一起，关键字：union, union all
    >
    > select .... union [all] select .....;

    ```sql
    -- 查询薪资大于等于15000，并且年龄大于45的员工信息
    select * from emp where salary>=15000
    union
    select * from emp where age>=45;
    ```

    

- 子查询

  > select之后，from之后，where之后

  - 标量子查询：子查询的结果是单个值

    > 操作符：比较运算符

    ```sql
    -- 查询技术部所有的员工信息
        -- 1.查询技术部的id
        select id from dep where name='技术部';
        -- 2.查询技术部所有员工信息
        select * from emp where dep_id=(select id from dep where name='技术部');
    
    -- 查询薪资比黄忠高的员工信息
        -- 1.查询黄忠的薪资
        select salary from emp where name='黄忠';
        -- 2.查询薪资比黄忠高的员工信息
        select * from emp where salary>(select salary from emp where name='黄忠');
    ```

    

  - 列子查询：子查询的结果是一列

    - in

      ```sql
      -- 查询人事部和财务部的所有员工
          -- 1.查询人事部和财务部id
          select id from dep where name='人事部' or name='财务部';
          -- 2.查询人事部和财务部的所有员工
          select * from emp where dep_id in (select id from dep where name='人事部' or name='财务部');
      ```

    - not in

    - any：子查询返回的列表中，有任何一个满足即可

    - some：同any

    - all：子查询返回列表的所有值，都必须满足

      ```sql
      -- 比市场部所有人入职都晚的员工信息
          -- 1.查询市场部的id
          select id from dep where name='市场部';
          -- 2.查询市场部所有人的入职日期
          select join_date from emp where dep_id=(select id from dep where name='市场部');
          -- 3.比市场部所有人入职都晚的员工信息
          select * from emp where join_date>all(select join_date from emp where dep_id=(select id from dep where name='市场部'));
      
          select max(join_date) from emp where dep_id=(select id from dep where name='市场部');
          select * from emp where join_date>(select max(join_date) from emp where dep_id=(select id from dep where name='市场部'));
      
      ```

      

  - 行子查询：子查询的结果是一行

    > 操作符：=	!=	in	not in

    ```sql
    -- 查询和关羽薪资相同，并且领导也相同的员工信息
        -- 1.查询关羽的薪资和领导id
        select salary, leader_id from emp where name='关羽';
        -- 2.查询其它员工信息
        select * from emp where (salary,leader_id)=(select salary, leader_id from emp where name='关羽');
        select * from emp where (salary,leader_id)!=(select salary, leader_id from emp where name='关羽');
        
        select * from emp where (salary,leader_id)not in((8000, 1), (6800, 2));
    ```

    

  - 表子查询：子查询的结果是多行多列

    > 操作符：in	not in

    ```sql
    
    select salary, leader_id from emp where name='关羽' or name='赵云';
    select * from emp where (salary,leader_id) in (
    	select salary, leader_id from emp where name='关羽' or name='赵云'
    );
    
    -- 查询工资为8000的员工信息，以及部门信息
        -- 1.查工资为8000的员工信息
        select * from emp where salary=8000;
        -- 2.查询这部分员工的部门信息
        select e.*, dep.name from (select * from emp where salary=8000) e left join dep on e.dep_id=dep.id;
    
        select emp.*, dep.name from emp left join dep on emp.dep_id=dep.id where emp.salary=8000;
    ```

    练习

    ```sql
    -- 职位等级表
    create table job_grade(
        id int primary key auto_increment,
        grade varchar(16),
        min_salary int,
        max_salary int
    );
    
    insert into job_grade(grade, min_salary, max_salary) values
    ('p1', 0, 4999),
    ('p2', 5000, 9999),
    ('p3', 10000, 14999),
    ('p4', 15000, 19999),
    ('p5', 20000, 29999),
    ('p6', 30000, 39999);
    
    
    -- 1.查询所有员工的职级
    -- 表：emp    job_grade
    -- 连接条件：emp.salary>=job_grade.min_salary and emp.salary<=job_grade.max_salary
    select emp.name, emp.salary, job_grade.grade, job_grade.min_salary, job_grade.max_salary
    from emp
             left join job_grade on emp.salary between job_grade.min_salary and job_grade.max_salary
    order by emp.id;
    
    -- 2.查询人事部所有员工信息，以及他们的职级
    -- 表：emp    job_grade   dep
    -- 连接条件：emp.salary>=job_grade.min_salary and emp.salary<=job_grade.max_salary   emp.dep_id=dep.id
    -- 查询条件：dep.name='人事部'
    select emp.*, job_grade.grade
    from emp
             join job_grade on emp.salary between job_grade.min_salary and job_grade.max_salary
             join dep on emp.dep_id = dep.id
    where dep.name = '人事部';
    
    -- 3.查询薪资低于每个部门平均值的员工信息
        -- 1.查询每个部门的平均薪资
        select avg(salary) from emp where dep_id=3;
        -- 2.查询薪资低于每个部门平均值的员工信息
        select * from emp;
    select b.*, (select avg(a.salary) from emp a where a.dep_id = b.dep_id) 'avg_salary'
    from emp b
    where salary < (select avg(a.salary) from emp a where a.dep_id = b.dep_id);
    
    -- 4.查询每个部门的员工数量
    select count(e.id) from emp e where e.dep_id=2;
    select d.name, (select count(e.id) from emp e where e.dep_id=d.id) '人数' from dep d;
    
    -- 多对多
    create table music(
        id int primary key auto_increment,
        name varchar(16)
    );
    insert into music(name) values
    ('以父之名'),('夜的第七章'),('止战之殇'),('夜曲'),('罗刹海市'),('北京欢迎你');
    
    create table singer(
        id int primary key auto_increment,
        name varchar(16)
    );
    insert into singer(name) values
    ('周杰伦'), ('刀郎'), ('刘欢'), ('韩红'), ('成龙');
    
    create table singer2music(
        id int primary key auto_increment,
        music_id int,
        singer_id int
    );
    insert into singer2music(music_id, singer_id) values
    (1, 1),(2, 1),(3, 1),(4, 1),(5, 2),(6, 3),(6, 4),(6, 5);
    
    -- 5.查询所有歌曲，以及对应的歌手
    -- 表：music  singer  singer2music
    -- 连接条件：music.id=singer2music.music_id  singer.id=singer2music.singer_id
    select m.name, s.name
    from music m
             join singer2music sm on m.id = sm.music_id
             join singer s on s.id = sm.singer_id;
    select m.name, s.name
    from music m,
         singer2music sm,
         singer s
    where m.id = sm.music_id
      and s.id = sm.singer_id;
    ```
    



## 14.数据库控制语言（DCL）

> 管理数据库的用户，控制数据库访问权限
>
> 用户a -> db1
>
> 用户b -> db1 db2

- 用户管理

  - 创建用户

    > create user '用户名'@'主机名' identified by '密码';

    ```sql
    create user 'fei'@'localhost' identified by '123';
    ```

    

  - 删除用户

    > drop user '用户名'@'主机名'

    ```sql
    drop user 'fei'@'localhost';
    ```

    

  - 修改用户

    > alter user '用户名'@'主机名' identified with mysql_native_password by '新密码';
    >
    > update mysql.user set host='主机名' where user='用户名';

    ```sql
    -- 修改密码
    alter user 'fei'@'localhost' identified with mysql_native_password by '456';
    -- 修改主机
    update mysql.user set host='%' where user='fei';
    ```

    

  - 查询用户

    > select * from mysql.user;

- 权限控制（运维.DBA）

  - all/all privileges：所有权限
  - insert：插入数据权限
  - delete：删除数据权限
  - udpate：修改数据权限
  - selete：查询数据权限
  - create：创建数据库/表权限
  - drop：删除数据库/表/视图权限
  - alter：修改表/字段权限

  查询权限

  > show grants for '用户名'@'主机名';

  ```sql
  show grants for 'fei'@'localhost';
  ```

  
  
  分配权限（授予权限）
  
  > grant 权限列表 on 库名.表名 to '用户名'@'主机名';
  
  ```sql
  grant all on db6.* to 'fei'@'localhost';
  ```
  
  
  
  撤销权限
  
  > revoke 权限列表 on 库名.表名 from ' 用户名'@'主机名';
  
  刷新权限
  
  > flush privileges;
  
  

## 15.事务

### 15.1事务概述

> 一组操作的集合（多条sql语句的集合），这个集合是一个不可分割的工作单位，它会把集合内的所有操作一起提交，如果提交过程中，有任何一条sql出现了错误，那便会回退到整个事务执行之前的状态，即：要么同时成功，要么同时失败。

```python
银行转账
李白	500
杜甫	1000

"""
开启事务
1 查询李白的余额
2 从李白账户-100
异常 -> 回滚
3 给杜甫账户+100
提交事务
"""
```

> 查看事务的提交方式：`select @@autocommit;`
>
> 设置事务的提交方式：`set @@autocommit=0;` -- 设置事务手动提交，1为自动提交
>
> 开启事务：`start transaction;`  或者：`begin;`
>
> 提交事务：`commit;`
>
> 回滚事务：`rollback;`

```sql
-- 账户表
create table account(
    id int primary key auto_increment,
    name varchar(16),
    balance int
);

insert into account(name, balance) values
('李白', 500),
('杜甫', 1000);

select @@autocommit;
set @@autocommit=1;

-- 开启事务
start transaction;
begin;

-- 1 查询李白的余额
select * from account where name = '李白';
-- 2 从李白账户上-100
update account set balance=balance - 100 where name = '李白';
print('发生异常了')
-- 3 给杜甫的账户+100
update account set balance=balance + 100 where name = '杜甫';


commit;     -- 提交事务
rollback;   -- 回滚事务
```



### 15.2 事务的四大特性

- 原子性（**A**tomicity）

  > 事务是不可分割的最小操作单元，这个操作单元要么全部成功，要么全部失败。

- 一致性（**C**onsisteny）

  > 事务完成的时候，必须使所有数据都保持一致状态。

- 隔离性（**I**solation）

  > 在并发的时候，A事务在操作的时候，它不会影响B事务的执行；B事务在操作的时候，也不会影响A事务。

- 持久性（**D**urability）

  > 事务不管是提交还是回滚，它对数据库里面数据的改变，都是永久的。

### 15.3 并发事务引发的问题

- 脏读

  > 一个事务读取到了另外一个事务还没有提交的数据

- 不可重复读

  > 一个事务先后读取同一条记录，但两次读取到数据不同。
  >
  > 事务a	500 .... 500
  >
  > 事务b	-100 commit

- 幻读

  > 一个事务查询某一条记录的时候，没有对应的记录，但是在插入记录的时候，又发现这条记录已经存在了，就好像出现了幻觉一样
  >
  > 事务a：select id=9 -> null insert id=9 -> error select id=9 -> null
  >
  > 事务b：insert id=9 commit

### 15.4 事务的隔离级别

| 隔离级别   | Read Uncommitted | Read Committed | Repeatable Read（默认） | Serializable |
| ---------- | :--------------: | :------------: | :---------------------: | :----------: |
| 脏读       |        ✔︎         |       ✗        |            ✗            |      ✗       |
| 不可重复读 |        ✔︎         |       ✔︎        |            ✗            |      ✗       |
| 幻读       |        ✔︎         |       ✔︎        |            ✔︎            |      ✗       |

问：我们在一个事务里面插入一批非常大的数据，这个事务已经执行了很长时间，并且还在执行过程中，没有提交，如何知道当前已经插入了多少条数据？

答：利用Read Uncommitted隔离级别，用一个新的事务，读取到这一批大数据的插入进度。



```sql
-- 查看事务隔离级别
select @@transaction_isolation

-- 设置事务隔离级别
set {session|global} transaction isolation level <隔离级别>;
```



# 进阶篇

## 1.MySQL体系结构图

![image-20240104120132072](E:\笔记\数据库\其他资源\数据库篇.assets\image-20240104120132072.png)

## 2.Innodb存储结构

![ ](数据库篇.assets/InnoDB存储结构图.png)



## 3.索引

### 3.1索引概述

> 索引是一种有序的数据结构，它可以帮助MySQL高效获取数据
>
> 二叉树，B-Tree，红黑树，B+Tree。。。。
>
> ~~增删改，索引节点也需要同步增删改，不用考虑，业务系统大多都是查~~

- **B+Tree索引**
- Hash索引
- FUll-Text索引
- R-Tree索引

|   索引    |   Innodb    | MyIsam | Memory |
| :-------: | :---------: | :----: | :----: |
|  B+Tree   |      ✔      |   ✔    |   ✔︎    |
|   Hash    |      ✗      |   ✗    |   ✔    |
| Full-Text | 5.6之后支持 |   ✔    |   ✗    |
|  R-Tree   |      ✗      |   ✔    |   ✗    |

- 二叉树

  > 顺序插入时，会形成链表，查询效率大幅度降低
  >
  > 数据结构可视化网站：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

  ![二叉树](数据库篇.assets/二叉树.png)

- 红黑树

  > 当数据量特别大的时候，层级非常深，查找速度同样会很慢

  ![截屏2023-08-11 20.01.44](数据库篇.assets/红黑树.png)



- B-Tree（多路平衡查找树）

  > 示例数据：30,45,52,48,16,69,80,71,12,18,25,94,96,91,115,99,110

  ![B-Tree](数据库篇.assets/B-Tree.png)

- B+Tree

  > 所有数据都会出现在叶子节点，叶子节点会形成一个单向链表

  ![B+Tree](数据库篇.assets/B+Tree.png)

- Hash索引

  > Memory支持
  >
  > Innodb里面也有一个自适应Hash功能，它会更具我们的查询条件，在特定情况下，自动更具B+Tree索引构建Hash索引

  ![Hash索引](数据库篇.assets/Hash索引.png)

- Innodb索引结构

  > 叶子节点使用双向链表，便于排序和范围查找。
  >
  > B+Tree非叶子节点不存数据，一页能存的指针和key就会更多，每个节点存的指针和key多了，相同数据量的情况下，B+Tree的高度肯定要比B-Tree更低，树的高度低了，查询次数就少了，磁盘io自然也少了

  ![Innodb B+Tree](数据库篇.assets/Innodb B+Tree.png)

  在Innodb里面，高度为2的B+Tree，以及高度为3的B+Tree，分别能存多少行数据？假设一行数据大小是1k

  ```
  一页大小：16k，16行
  指针：6字节
  key：int，4字节
  key数量：n，类型int
  4n+6n+6=16x1024   10n+6=16384	10n=16378	n=1637.8
  key：1637	指针：1638
  高度为2： 1638x16≈26000条
  高度为3： 1638x1638x16≈4200万条	1638x1638x32≈8400万条
  ```

### 3.2 索引分类

- 主键索引
- 唯一索引
- 常规索引
- 全文索引

存储形式不同：

- 聚集索引（聚簇索引）
- 二级索引（辅助索引，非聚集索引）

> 如果存在主键，主键索引就是聚集索引；
>
> 如果不存在主键，第一个唯一字段，将会被作为聚集索引；
>
> 如果没有主键，也没有唯一字段，Innodb会自动生成一个rowid，作为隐藏的聚集索引

![回表查询](数据库篇.assets/回表查询.png)



### 3.3 索引语法

- 创建索引

  > create {unique|fulltext} index 索引名称 on 表名(字段名...);

- 查询索引

  > show index from 表名;

- 删除索引

  > drop index 索引名称 on 表名;

```sql

create database db1 charset utf8mb4;
use db1;

create table emp(
    id int primary key auto_increment,
    name varchar(16) not null,
    gender enum('male', 'female') not null,
    phone varchar(11) not null,
    email varchar(50),
    age int not null,
    salary float(10, 2),
    post varchar(16),
    join_date date,
    leader_id int
);


insert into emp
values (1, '刘备', 'male', '13035445001', 'abcdabcdeabc@qq.com', 32, 4000, '总经理', '2035-06-01', null),

       (2, '关羽', 'male', '13035445002', 'abcdabcdeghefg@qq.com', 20, 8000, '技术总监', '2035-06-05', 1),
       (3, '张飞', 'male', '13035445003', 'ijklijklijk@qq.com', 25, 12000, '项目经理', '2035-06-10', 2),
       (4, '赵云', 'male', '13035445004', 'abmnoepmnopmno@qq.com', 19, 6800, '产品经理', '2035-06-10', 2),
       (5, '马超', 'male', '13035445005', 'abqrstqrstqrs@qq.com', 26, 11000, '后端开发', '2035-07-11', 2),
       (6, '黄忠', 'female', '13035445006', 'abuvwxuvwxuvw@qq.com', 48, 15000, '后端开发', '2035-07-22', 2),
       (7, '夏侯惇', 'male', '13035445007', 'yzabyzabyza@qq.com', 36, 34000, '后端开发', '2035-07-29', 2),
       (8, '典韦', 'male', '13035445008', 'cdefcdefcdef@qq.com', 19, 6800, '后端开发', '2035-08-02', 2),
       (9, '吕布', 'female', '13035445009', 'ghijghijghij@qq.com', 20, 9000, '前端开发', '2035-08-03', 2),
       (10, '周瑜', 'female', '13035445010', 'klmnklmnklmn@qq.com', 32, 36000, '前端开发', '2035-08-08', 2),
       (11, '文丑', 'male', '13035445011', 'opqropqropqr@qq.com', 27, 24000, '测试', '2035-08-12', 2),

       (12, '诸葛亮', 'male', '13035445012', 'stuevstuvstuv@qq.com', 27, 8000, '市场总监', '2035-06-05', 1),
       (13, '庞统', 'male', '13035445013', 'wxyezwxyzwxy@qq.com', 37, 4200, '销售', '2035-06-06', 12),
       (14, '徐庶', 'male', '13035445014', 'xabcdefghijk@qq.com', 36, 4000, '销售', '2035-06-12', 12),
       (15, '荀彧', 'male', '13035445015', 'lmnopqrstuv@qq.com', 25, 2400, '销售', '2035-06-10', 12),
       (16, '荀攸', 'male', '13035445016', 'wxyszabcdefg@qq.com', 25, 2400, '销售', '2035-06-12', 12),
       (17, '鲁肃', 'male', '13035445017', 'hijklmnopqr@qq.com', 43, 4300, '销售', '2035-06-18', 12),
       (18, '司马懿', 'female', '13035445018', 'stuvwxyzabc@qq.com', 44, 5000, '销售', '2035-06-20', 12),
       (19, '杨修', 'male', '13035445019', 'defghijklmn@qq.com', 19, 800, '销售', '2035-07-10', 12),
       (20, '丁仪', 'male', '13035445020', 'opqsrstuvwxy@qq.com', 49, 3500, '销售', '2035-07-11', 12),

       (21, '宋江', 'male', '13035445021', 'zabcdefghijkl@qq.com', 30, 8000, '人事总监', '2035-06-05', 1),
       (22, '吴用', 'male', '13035445022', 'mnopqrstuvwxyz@qq.com', 38, 3000, '人事主管', '2035-06-06', 21),
       (23, '扈三娘', 'female', '13035445023', 'sabcdefghijklm@qq.com', 42, 2500, '招聘专员', '2035-06-11', 21),
       (24, '顾大嫂', 'female', '13035445024', 'fnopqrstuvwxyz@qq.com', 38, 3300, '招聘专员', '2035-06-25', 21),
       (25, '孙二娘', 'female', '13035445025', 'wabcdefghijklf@qq.com', 32, 2400, '绩效专员', '2035-07-22', 21),
       (26, '丁得孙', 'male', '13035445026', 'enopqrstuvwxyz@qq.com', 32, 2800, '培训专员', '2035-08-10', 21),


       (27, '柴进', 'male', '13035445027', 'tabcdefghijkli@qq.com', 30, 8000, '财务总监', '2035-06-05', 1),
       (28, '卢俊义', 'male', '13035445028', 'inopqrstuvwxyz@qq.com', 44, 4000, '会计', '2035-08-19', 27),
       (29, '晁盖', 'male', '13035445029', 'oabcdefghijkle@qq.com', 44, 3500, '出纳', '2035-08-20', 27),

       (30, '貂蝉', 'female', '13035445030', 'wnopqrstuvwxyz@qq.com', 36, 800, null, '2035-09-01', null);

```

```sql
# 全文索引测试
create table articles(content varchar(5000));
insert into articles values
('这几天心里颇不宁静。今晚在院子里坐着乘凉，忽然想起日日走过的荷塘，在这满月的光里，总该另有一番样子吧。月亮渐渐地升高了，墙外马路上孩子们的欢笑，已经听不见了；妻在屋里拍着闰儿，迷迷糊糊地哼着眠歌。我悄悄地披了大衫，带上门出去。'),
('这时我看见他的背影，我的泪很快地流下来了。我赶紧拭干了泪。怕他看见，也怕别人看见。我再向外看时，他已抱了朱红的橘子往回走了。过铁道时，他先将橘子散放在地上，自己慢慢爬下，再抱起橘子走。到这边时，我赶紧去搀他。他和我走到车上，将橘子一股脑儿放在我的皮大衣上。'),
('Life is too short to spend time with people who suck the happiness out of you. If someone wants you in their life, they’ll make room for you. You shouldn’t have to fight for a spot. Never, ever insist yourself to someone who continuously overlooks your worth. And remember, it’s not the people that stand by your side when you’re at your best, but the ones who stand beside you when you’re at your worst that are your true friends.');

# 创建全文索引，并指定解析器：ngram，MySQL5.7.6以后内置了ngram解析器，支持中文全文索引
create fulltext index idx_articles_content on articles(content) with parser ngram;

# 用全文索引查询，语法条件：match(字段名) against('关键词')
select * from articles where match(content) against('月亮');

# 创建表的时候创建全文索引
create table articles(
    content varchar(5000),
    fulltext (content) with parser ngram
);
```

### 3.4 SQL性能分析

- 查询SQL执行频次

  ```SQL
  show global status like 'com_insert';
  show global status like 'com_delete';
  show global status like 'com_update';
  show global status like 'com_select';
  
  show global status like 'com_______';
  
  show global status where variable_name rlike 'com_[idus][enp].{4}$';
  ```
  
- 慢查询日志

  ```sql
  -- 查询状态
  show variables like 'slow%';
  select @@slow_query_log;
  select @@long_query_time;
  select @@slow_query_log_file;
  
  -- 设置状态（重启后失效）
  set @@global.slow_query_log=1;
  set @@global.long_query_time=2;
  -- 重启有效
  vi /etc/my.cnf
  [mysqld]
  slow_query_log=1
  long_query_time=2
  ```


- profile

  ```sql
  select @@have_profiling;    -- 查看是否支持profiling;
  select @@profiling;         -- 查看是否打开profiling
  set profiling = 1;          -- 打开profiling
  
  show profiles;	-- 查询最近的sql执行耗时情况
  show profiles for query <query_id>;		-- 查询某一条sql的耗时具体情况
  show profiles cpu for query <query_id>;		-- 查询某一条sql的耗时具体情况以及cpu情况
  ```

- explain

  ```sql
  explain <select语句>
  
  '''
  type:访问类型
  性能从差到好为:all<index<range<index_merge<ref<eq_ref<const<system<NULL
  '''
  ```


### 3.5 索引失效情况

- 最左前缀法则(**联合索引**)

  > 最左列必须存在,并且不跳过索引中间的列,如果跳过了联合索引中的某一列,后面的字段索引将会失效
  >
  > 如果出现了范围查询,范围查询右侧的索引将会失效

- 运算操作

- 前面模糊匹配

- 字符串不加引号

- or两侧用到的列,有一侧没有索引

- 数据分部影响

### 3.6 SQL提示

- use index()

  > 建议走某个索引

  ```sql
  select * from emp use index(idx_emp_age) where age=25; 
  ```

- ignore index()

  > 不要走某个索引

  ```sql
  select * from emp ignore index(idx_emp_age) where age=25; 
  ```

- force index()

  > 强制走某个索引

  ```sql
  select * from emp force index(idx_emp_age) where age=25; 
  ```

  

### 3.7 覆盖索引

> 查询的时候使用了索引,而且需要返回的列,在该索引里面已经能全部找到

```SQL
explain select * from emp where age=25 and salary=2400 and post='销售';
explain select id, name, age from emp where age=25 and salary=2400 and post='销售';
explain select id, salary, post from emp where age=25 and salary=2400 and post='销售';
explain select id, age, salary, post from emp where age=25 and salary=2400 and post='销售';
```



### 3.8 前缀索引

> create index 索引名 on 表名(字段名(n));

选择性:不重复的索引值,和总记录数的比值



### 3.9 索引的选择

> 如果频繁出现了多个查询条件,就要考虑给这些查询字段,创建联合索引,而不是创建单列索引



### 总结

- 对于数据量较大（100万），并且查询比较频繁的表，我们就应该为它创建索引
- 一般都是选择查询条件、排序条件、或者分组条件用到的字段来创建索引
- 选择字段的时候，要尽量选择区分度较高的列作为索引，也就是尽量建立唯一索引，因为区分度越高，索引的效率越高
- 尽量创建联合索引，联合索引很多场景下可以覆盖索引，效率更高，要注意字段顺序
- 字符串较长，可以建立前缀索引，以此来降低索引的体积，减少磁盘io，提高效率
- 索引的数量并不是越多越好，索引越多，确实能够更好的提升查询效率，但同时也意味着，增删改的时候，效率会更加的低，因为每一次增删改，都需要维护索引
- 如果一个字段不能为null，我们就应该加上not null约束，有了这个约束之后，优化器可以更精确地估计查询条件的过滤效果，并且制定更准确的查询执行计划，更快地返回结果



## 4. SQL优化

### 4.1 insert优化

- 批量插入

  ```sql
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  ```

  

- 手动提交事务

  ```sql
  begin;
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  insert into table_name values(1, 'fei'), (2, 'jack'), (3, 'rose'), (4, 'tom');
  commit;
  ```

  

- 大批量数据插入

  ```sql
  mysql --local-infile -uroot -p
  set global local_infile=1;
  
  # mysql5.7直接用，8.0需要前面两步
  load data local infile '文件路径' into table 表名 fields terminated by '字段分隔符' lines terminated by '换行符';
  ```

  

- 主键顺序插入

  > 顺序插入的性能，要比乱序插入更高



### 4.2 主键优化

- 数据的组织方式

  > 根据主键顺序存放

  ![Innodb B+Tree](数据库篇.assets/Innodb B+Tree-3875517.png)

- 页分裂
- 页合并
- 主键的设计原则
  - 插入数据的时候，要尽量顺序插入，最好给主键设置自增
  - 尽量不要使用太复杂的值作为主键，比如：uuid，各种证件号码
  - 尽量降低主键的长度
  - 尽量不要修改主键



### 4.3 group by 优化

> 单列索引或联合索引都有效
>
> 联合索引需要遵循最左前缀法则

```sql
show index from emp;
create index idx_emp_post_salary_age on emp(post, salary, age);

select post, count(*) from emp group by post;
select post, salary, count(*) from emp group by post, salary;
select post, salary, count(*) from emp where post='销售' group by salary;
explain select post, salary, count(*) from emp where post='销售' group by salary;
```



### 4.4 order by 优化

- Using index

  > 通过有序索引顺序扫描，直接返回有序的数据，不需要额外的排序，效率比较高

- Using filesort

  > 通过索引或者全表扫描，读取满足条件的记录，然后在排序缓冲区里面完成排序操作，只要不是通过索引直接返回排序结果的排序，都是filesort

- 联合索引结构

![联合索引1](数据库篇.assets/联合索引1.png)

![联合索引2](数据库篇.assets/联合索引2.png)

总结：

- 尽量使用覆盖索引

- 对于多字段排序，需要遵循最左前缀法则

- 如果需要一个升序，一个降序，要在创建联合索引的时候，指定号排序规则（8.0后支持）

- MySQL缓冲区大小默认是256k，如果是大数据量要进行filesort，可以根据实际情况，适当增大排序缓冲区

  ```sql
  select @@sort_buffer_size;
  ```

  

### 4.5 limit优化

> 覆盖索引+子查询
>
> select d.* from test_data d join (select id from test_data limit 40000000, 10) t on d.id=t.id;



### 4.6 count优化

- **count(*)**

  > 和count(数字)差不多，不取值，直接累加，同时Innodb对它还做了优化

- count(数字)

  > Innodb会遍历整张表，不取值，只要遍历到一行记录，就会用一个数字作为这行记录的值，然后直接计数累加

- count(主键)

  > Innodb会遍历整张表，把每一行的主键都取出来，取出一个主键，计数就+1

- count(字段名)

  > 判断当前字段是否有not null约束
  >
  > 如果没有，Innodb会遍历整张表，把每一行的字段值都取出来，然后判断是否为null，不为null，则计数累加
  >
  > 如果有，Innodb会遍历整张表，把每一行的字段值都取出来，直接计数累加



### 4.7 update优化

> 要根据有索引的字段进行更新，不然就会出现行锁升级为表锁，Innodb的行锁是针对索引加的锁，不是针对记录加的锁，而且这个索引不能失效，如果索引失效，行锁同样会升级为表锁



## 5. 视图

> 视图是一种虚拟存在的表，它只保存SQL逻辑，不保存查询结果
>
> create [or replace] view 视图名[(字段名...)] as select语句 [with [cascaded | local] check option];

```sql
-- 创建视图
create view emp_v1 as select id, name, age from emp where id <= 5;

-- 查询视图
select * from emp_v1 where id <= 5;

-- 修改视图
create or replace view emp_v1 as select id, name, age from emp where id <= 10;
alter view emp_v1 as select id, name, age, post from emp where id <= 10;

-- 删除视图
drop view if exists emp_v1;
```

- cascaded

  > 级联检查依赖的视图

- local

  > 只检查当前视图

- 视图更新条件

  > 视图中的行，与基表中的行，必须存在一对一关系
  >
  > 如果出现以下情况，视图将不可更新：
  
  1. 聚合函数或者窗口函数
  2. 出现了distinct
  3. group by
  4. having
  5. union



视图作用：

- 简化操作
- 安全
- 屏蔽基表结构变化的影响

```sql
create table music(
    id int primary key auto_increment,
    name varchar(16)
);
insert into music(name) values
('以父之名'),('夜的第七章'),('止战之殇'),('夜曲'),('罗刹海市'),('北京欢迎你');

create table singer(
    id int primary key auto_increment,
    name varchar(16)
);
insert into singer(name) values
('周杰伦'), ('刀郎'), ('刘欢'), ('韩红'), ('成龙');

create table singer2music(
    id int primary key auto_increment,
    music_id int,
    singer_id int
);
insert into singer2music(music_id, singer_id) values
(1, 1),(2, 1),(3, 1),(4, 1),(5, 2),(6, 3),(6, 4),(6, 5);


select music.id, music.name, singer.name from music, singer, singer2music where music.id=singer2music.music_id and singer.id=singer2music.singer_id;


create or replace view sm as select music.id, music.name, singer.name s_name from music, singer, singer2music where music.id=singer2music.music_id and singer.id=singer2music.singer_id;

select * from sm;
```

































